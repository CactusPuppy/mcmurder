package com.github.cactuspuppy.mcmurder.utils;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.apache.commons.io.FileUtils;
import org.bukkit.command.CommandExecutor;
import org.bukkit.configuration.InvalidConfigurationException;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.*;
import java.nio.charset.Charset;
import java.util.*;
import java.util.regex.Pattern;

/**
 * Custom YML parser supporting #comments and indented key-value pairs
 *
 * @author CactusPuppy
 */
@SuppressWarnings("WeakerAccess")
@NoArgsConstructor
public class Config implements Map<String, String> {
    /**
     * How many spaces each level should indent
     */
    @Getter @Setter
    private int spacesPerIndent = 2;

    /**
     * Pattern to find key-value pairs
     */
    private static final Pattern KEY_VALUE_MATCHER = Pattern.compile("^( *)([^:\\n]+):( *)([^:\\n]*)$");

    /**
     * Pattern to capture comments
     */
    private static final Pattern COMMENT_MATCHER = Pattern.compile("([^#\\n]*?)( *# *.*)");

    /**
     * Root node of the config. All nodes should be children of this node.
     */
    private Node rootNode = new BlankNode(0, 0);

    /**
     * Flat map of all string keys. Does not include comments.
     */
    private Map<String, String> cache = new HashMap<>();

    /**
     * Loads the specified YAML-style file into the config, dropping all previous keys, values, and comments.
     * @param configFile File to load from
     * @throws IllegalArgumentException      If {@code configFile} is null
     * @throws InvalidConfigurationException If the file is not a valid config file
     * @throws IOException                   If the file cannot be read for any reason
     */
    public void load(File configFile) throws IllegalArgumentException, InvalidConfigurationException, IOException {
        if (configFile == null) {
            throw new IllegalArgumentException("Config file must not be null");
        }
        try (FileInputStream fIS = new FileInputStream(configFile)) {
            loadInputStream(fIS);
        }
    }

    /**
     * Loads the specified YAML-style file into the config, dropping all previous keys, values, and comments.
     * @param fileName File to load
     * @throws IllegalArgumentException      If {@code fileName} is null or empty
     * @throws InvalidConfigurationException If the file is not a valid config file
     * @throws IOException                   If the file cannot be read for any reason
     * @throws FileNotFoundException         If the file corresponding to {@code fileName} could not be found
     */
    public void load(String fileName) throws IllegalArgumentException, FileNotFoundException,
                                             InvalidConfigurationException, IOException {
        if (fileName == null || fileName.equals("")) {
            throw new IllegalArgumentException("Filename must not be empty or null");
        }
        File configFile = new File(fileName);
        if (!configFile.isFile()) {
            throw new FileNotFoundException(String.format("File %s could not be found", fileName));
        }
        load(configFile);
    }

    /**
     * Loads a config string generated by {@link #saveToString()} or read from a valid YAML-style
     * config file, dropping all previous keys, values, and comments.
     * @param configString String to read from
     * @throws IllegalArgumentException If {@code configString} is null or empty
     * @throws InvalidConfigurationException If {@code configString} is not a valid config string
     */
    public void loadFromString(String configString) throws IllegalArgumentException, InvalidConfigurationException {
        if (configString == null || configString.equals("")) {
            throw new IllegalArgumentException("Filename must not be empty or null");
        }
        loadInputStream(new ByteArrayInputStream(configString.getBytes()));
    }

    private void loadInputStream(InputStream stream) throws InvalidConfigurationException {
        int lineIndex = 0;
        try (Scanner scan = new Scanner(stream)) {
            //Track indent levels
            LinkedList<Integer> currIndents = new LinkedList<>();
            currIndents.addLast(0);

            List<Node> currentParents = new ArrayList<>();
            currentParents.add(rootNode);
            Node previousKeyNode = null;
            int prevIndent = 0;

            while (scan.hasNextLine()) {
                String line = scan.nextLine();
                lineIndex++;

                //Comment handling
            }
        } catch (NoSuchElementException | IllegalStateException e) {
            Logger.logSevere(this.getClass(),
            "Exception while parsing new config input stream at line " + lineIndex, e);
            throw new InvalidConfigurationException();
        }
    }

    /**
     * Generates a config string that can be used to reconstruct the current state of the config
     * @return The generated config string
     */
    public String saveToString() {
        //TODO
        return null;
    }

    /**
     * Saves the current config to the specified file, creating the file and any parent directories
     * if it does not exist and overwriting the previous file if it does.
     * @param file File to write to
     * @throws IllegalArgumentException If {@code file} is null
     * @throws IOException              If the {@code file} could not be written to for any reason
     */
    public void save(File file) throws IllegalArgumentException, IOException {
        if (file == null) {
            throw new IllegalArgumentException("Provided file may not be null");
        }
        String config = saveToString();
        FileUtils.writeStringToFile(file, config, (String) null);
    }

    /** The number of key-value pairs currently stored in the config */
    @Override
    public int size() {
        return cache.size();
    }

    /** Returns true if no key-value pairs are stored in the config */
    @Override
    public boolean isEmpty() {
        return cache.isEmpty();
    }

    @Override
    public boolean containsKey(Object key) {
        return cache.containsKey(key);
    }

    @Override
    public boolean containsValue(Object value) {
        return cache.containsValue(value);
    }

    @Override
    public String get(Object key) {
        return cache.get(key);
    }

    @SuppressWarnings("SuspiciousMethodCalls")
    @Override
    public String getOrDefault(Object key, String def) {
        return cache.getOrDefault(key, def);
    }

    @Nullable
    @Override
    public String put(String key, String value) {
        //TODO
        return null;
    }

    /**
     * Insert a key-value pair with a trailing comment
     * @param key     Key to insert
     * @param value   Value to associate with the key
     * @param comment Comment to append to the end of the line
     *                in the config
     * @return The previous value associated with the key, or null if there was no mapping
     */
    public String put(String key, String value, String comment) {
        //TODO
        return null;
    }

    /**
     * Removes this key from the Config completely, along with any of its children.
     * Under most circumstances, {@link Config#unset(Object)} is probably the desired operation.
     * @param key Key to remove
     * @return The value previously mapped to the key, if any.
     */
    @Override
    public String remove(Object key) {
        //TODO
        return null;
    }

    /**
     * Add a standalone comment to the end of the config.<br/>
     * This comment is automatically prepended by "#";
     * any spaces after the "#" must be manually included in {@code comment}.
     * @param comment Comment to add
     * @param indent Number of spaces to indent by
     */
    public void addComment(String comment, int indent) {
        //TODO
    }

    /**
     * Add a standalone comment to the end of the config,<br/>
     * optionally matching the indentation of the previous node
     * @param comment         Comment to add
     * @param matchPrevIndent Whether to match the previous node's indentation
     *                        or use 0 indentation
     *
     * @see #addComment(String, int)
     */
    public void addComment(String comment, boolean matchPrevIndent) {
        //TODO
    }

    /**
     * {@code indent} defaulted to 0
     *
     * @see #addComment(String, int)
     */
    public void addComment(String comment) {
        addComment(comment, 0);
    }

    /**
     * Add a series of blank lines to the end of the config
     * @param lines Number of blank lines to add
     * @param indent Number of spaces to indent these lines by
     */
    public void addBlankLines(int lines, int indent) {
        //TODO
    }

    /**
     * Add a series of blank lines to the end of the config
     * @param lines           Number of blank lines to add
     * @param matchPrevIndent Whether to match the previous node's indentation
     *                        or use 0 indentation
     */
    public void addBlankLines(int lines, boolean matchPrevIndent) {
        //TODO
    }

    /**
     * {@code indent} defaulted to 0
     *
     * @see #addBlankLines(int, int)
     */
    public void addBlankLines(int lines) {
        addBlankLines(lines, 0);
    }

    /**
     * Removes the mapping of this key while maintaining all child mappings
     * @param key Key whose mapping should be removed
     * @return The value previously mapped to the key, if any.
     */
    public String unset(Object key) {
        //TODO
        return null;
    }

    @Override
    public void putAll(@NotNull Map<? extends String, ? extends String> m) {
        for (String key : m.keySet()) {
            put(key, m.get(key));
        }
    }

    /**
     * Removes all keys, values, and comments from the config
     */
    @Override
    public void clear() {
        rootNode.children.clear();
        cache.clear();
    }

    /**
     * Get an unmodifiable snapshot of the current cache which throws an {@link UnsupportedOperationException}
     * exception if any mutation is attempted.
     * @return An unmodifiable copy of the cache.
     */
    public Map<String, String> getCache() {
        return Collections.unmodifiableMap(cache);
    }

    @NotNull
    @Override
    public Set<String> keySet() {
        return cache.keySet();
    }

    @NotNull
    @Override
    public Collection<String> values() {
        return cache.values();
    }

    @NotNull
    @Override
    public Set<Entry<String, String>> entrySet() {
        return cache.entrySet();
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Map) {
            return cache.equals(obj);
        }
        return false;
    }

    /**
     * Represents one section of the config
     */
    @Getter @Setter
    private abstract class Node {
        private List<Node> children = new ArrayList<>();
    }

    /**
     * Represents a key-value pair which may be followed by a comment
     */
    @Getter @Setter
    private class KeyNode extends CommentNode {
        private String key = null;
        private int colonSpace;
        private String value = null;

        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof KeyNode)) {
                return false;
            }
            KeyNode other = (KeyNode) obj;
            return key.equals(other.key) && value.equals(other.value);
        }
    }

    /**
     * Represents a # prefixed comment
     */
    @Getter @Setter
    private class CommentNode extends Node {
        private String comment = null;

        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof CommentNode)) {
                return false;
            }
            return comment.equals(((CommentNode) obj).comment);
        }
    }

    /**
     * Represents one or more blank lines.
     * These lines
     */
    @Getter @Setter
    @AllArgsConstructor
    private class BlankNode extends Node {
        /**
         * Number of blank lines this node accounts for.
         */
        private int lineCount;
        /**
         * Number of spaces to indent these lines by
         */
        private int indent;

        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof BlankNode)) {
                return false;
            }
            return lineCount == ((BlankNode) obj).lineCount;
        }
    }
}